from datetime import timedelta

from django.contrib.auth.models import User
from django.db import models
import requests
import json

from django.utils import timezone

from giverofepic.settings import USED_HOST
from integrations.models import FormResult
from wallet.default_settings import (
    ERROR, SUCCESS, QUIZ_LINKS_LIFETIME_MINUTES, LOCAL_WALLET_API_URL, API_KEY_HEADER, QUIZ_API_KEY
    )
from giverofepic.tools import Encryption, get_secret_value, get_short
from wallet.epic_sdk import utils
from wallet.epic_sdk.utils import logger


# i4uX1o1O.LtnYTozsbpsxMD5KcbKJCARVOyqLO5gNhHOlNL1G9uxM1XFeJMES5G4Y


class Link(models.Model):
    issuer_api_key = models.CharField(max_length=128)
    ready_link = models.CharField(max_length=128, default='')
    claim_date = models.DateTimeField(null=True, blank=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    reusable = models.IntegerField(default=0, null=True)
    personal = models.BooleanField(default=True)
    currency = models.CharField(max_length=10, default='EPIC')
    claimed = models.BooleanField(default=False)
    expires = models.DateTimeField(default=timezone.now() + timedelta(minutes=QUIZ_LINKS_LIFETIME_MINUTES))
    address = models.CharField(max_length=128, help_text="receiver wallet address", blank=True)
    amount = models.DecimalField(max_digits=16, decimal_places=3, help_text="amount of currency to send")
    event = models.CharField(max_length=64, default='giveaway')
    code = models.CharField(max_length=64, default='')

    def get_url(self):
        """https://giverofepic.com/claim/GIVEAWAY_0.01-Vex_hp45tR"""
        # If 'code' is not provided it means that is a 'giveaway' link
        if not self.code:
            amount = int(self.amount) if 0 < self.amount > 1 else f"{self.amount:.2f}"
            timestamp = int(self.timestamp.timestamp())
            code_prefix = f"{self.event.upper()[:8]}_{amount}"
            to_encrypt = str((self.address, self.amount, timestamp, self.timestamp.isoformat()))
            code_validator = f"{Encryption(secret_key=self.issuer_api_key).encrypt(to_encrypt)}"
            self.code = f"{code_prefix}-{code_validator[-10:]}"
            self.ready_link = f"{USED_HOST}/claim/{self.code}"

        # otherwise it is a quiz link, 'code' was generated by forms.app
        else:
            self.ready_link = f"{USED_HOST}/claim/{self.code}"

        self.save()
        return self.ready_link

    @classmethod
    def validate(cls, code: str):
        """
        domain.com/claim/<code>
        https://giverofepic.com/claim/GIVEAWAY_0.01-Vex_hp45tR"""
        link_record = Link.objects.filter(code=code).first()

        if not link_record:
            message = 'Invalid code'
            return utils.response(ERROR, message)

        message = f"link successfully validated"
        logger.info(message)
        return utils.response(SUCCESS, message, link_record)

    def request_transaction(self):
        params = {
            'address': self.address,
            'amount': float(self.amount),
            'event': self.event,
            'code': self.code
            }
        response = self._wallet_api(query='request_transaction', params=params)

        if not response['error']:
            # If link is reusable update its counter
            if self.reusable > 0:
                self.reusable -= 1
                self.save()
                logger.info(f"Claiming reusable link, {self.reusable} times left")

            self.claimed = True
            self.save()

        return response

    @classmethod
    def _process_quiz_link(cls, link):
        # TODO: get user address
        params = {'address': link.address, 'amount': float(link.amount), 'event': link.event}
        response = cls._wallet_api(query='request_transaction', params=params)

        if not response['error']:
            form = FormResult.objects.get(session_id=link.code)
            form.claimed = True
            link.claimed = True
            form.save(), link.save()

        return response

    @classmethod
    def _process_in_blanco_link(cls, link):
        # TODO: get user address
        params = {'address': link.address, 'amount': float(link.amount), 'event': link.event}
        response = cls._wallet_api(query='request_transaction', params=params)

        if not response['error']:
            link.claimed = True
            link.save()

        return response

    @staticmethod
    def _wallet_api(query: str, params: dict):
        url = f"http://{LOCAL_WALLET_API_URL}/{query}"
        headers = {API_KEY_HEADER: QUIZ_API_KEY}
        response = requests.post(url, json=params, headers=headers)

        if response.status_code in [200, 202]:
            if response.json()['error']:
                logger.error(response.json()['message'])
            return response.json()
        else:
            print(response.text)

    def __str__(self):
        if self.claimed:
            icon = "ðŸŸ¢"
        else:
            icon = "ðŸŸ¡"
        return f"{icon} {self.event.upper()} CODE: {self.amount} {self.currency} -> {get_short(self.address)}"
